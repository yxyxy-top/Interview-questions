简单介绍下你们的项目
我最近这个项目框架是基于Spring+SpringMVC+Mybatis分布式架构，采用分布式服务框架是阿里的HSF，数据库使用的是阿里的RDS和DRDS，消息队列用的是ONS，搜索引擎使用的是opensearch，
前台页面使用Freemark页面静态化，由后台内容管理系统发布，静态页面存储在OSS当中，

jvm
jvm分区
JVM内存区域分为五个部分，分别是堆，方法区，虚拟机栈，本地方法栈，程序计数器，
不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：

程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；
Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；
本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；
Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；也是垃圾回收的主要区域，分为新生代和老年代，新生代又分为Eden和Survivor Space
方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
1.8版本后移除方法区，新增元空间作用和方法区差不多。

双亲委派制
双亲委派机制就是当一个类收到类加载请求的时候，它自己不会先加载，而是交给他的父类来加载，
如果他的父类还有父类的话，就进一步向上委托，直到找到最顶层的的启动类加载器，如果最顶层的
父类加载器可以加载就成功返回，如果父类无法加载，子类就会自己尝试加载，这就是双亲委派机制，
双亲委派的作用就是为了避免类的重复加载，当父类加载后，子类就不会自己加载，比如String类，
如果我们自己实现String类的话类加载器是不会加载到的。
类加载机制：
首先是bootstrapClassLoader类加载器，他是用来加载java的核心类的，是由原生代码来实现的，并不是继承制java.lang.ClassLoader，这个加载器是加载rt.jar的里的所有class的，由C++实现。
然后是extensionClassLoader类加载器，他是负责加载JRE的扩展目录，ext目录下的jar包的类。
然后是appClassLoader类加载器，这是系统类加载器，他负责加载classpath指定路径下的类库。

垃圾回收算法：
1标记清除算法
先标记处需要回收的对象，一般使用可达性算法，再去清除，但是会有效率问题和空间问题，会造成内存中出现很多不连续的空间，
当要分配一个大对象的时候，在进行寻找空间需要花费很长时间，可能会再一次触发垃圾回收。
2.复制算法
是将内存分为大小相同的两块，每次只使用其中一块，当这块内存使用完了，就将存活的对象复制到另一块上面，然后再把自己使用过的清除掉，
这样每次都只对整个半区进行内存回收，内存分配也不会出现内存碎片等复杂情况，但是这种算法的代价是将内存缩小为原来的一半浪费较大。

java集合
主要有两个集合接口
一个是Collection接口，这个接口下边主要有List和Set，List常用的子类有ArrayList和LinkedList和Vector，
Arraylist和Vector的数据结构都是动态数组的形式，两个的区别主要是Arraylist不是线程安全的，Vector是线程安全的，
Vector在每个操作上加了synchronized，又因为Vector是线程安全的所以在执行效率上要比Arraylist慢些，
LinkedList的数据结构式双向链表，它的每个节点里又分别指向上一个节点和下一个节点，当我们进行增删改时，
只需要修改节点的指向所以比较快，而查询的话LinkedList就比较慢，因为它会对整个数据进行遍历才能找到对应的数据，
Arraylist内部以数组的形式保存数据，所以在随机访问集合元素有比较好的性能。
Set常用的子类有HashSet，linkedHashSet和TreeSet，HashSet是无序不可重复的，而linkedHashSet是有序的，
因为linkedHashSet要维护数据的顺序所以性能比HashSet低些，TreeSet也是有序的，因为要额外的红黑树算法来维护元素的顺序，
如果需要一个保持顺序的Set的话就用TreeSet，不需要保持顺序的话就用HashSet，Set都是线程不安全的。
另一个是Map接口，常用的子类有HashMap和HashTable，而HashMap的数据结构是数组加链表加红黑树，HashMap允许键值对为空，但只能有一条记录，
HashMap是线程不安全的相对的线程安全的是ConCurrentHashMap，当存储数据时HashMap会通过剑的HashCode来计算出来hash值，根据hash值将数据保存在bucket里边，
当计算出来的hash值是相同的时候就会出现hash冲突，HashMap使用链表来解决hash冲突问题，对象会存储在链表的下一个节点中。
Hashtable和HashMap基本一致，HashMap是线程不安全的，HashTable是线程安全的，所以在效率上HashMap要比HashTable快。

数据库的4个隔离级别
1未提交读
未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。
2提交读
提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。
3.可重复读
可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。
4.串行化
最高的隔离级别，它通过强制事务串行执行，由于加了大量锁，导致大量请求的时候性能会比较低。

说一下 JVM 调优的工具？
JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

jconsole：用于对 JVM 中的内存、线程和类等进行监控；
jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。

什么是 spring boot？
spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。
配置简单
独立运行
自动装配
无代码生成和 xml 配置
提供应用监控
易上手
提升开发效率

spring事务的隔离级别
TransactionDefinition.ISOLATION_DEFAULT 				使用底层数据库的默认隔离级别。
TransactionDefinition.ISOLATION_READ_UNCOMMITTED  		一个事务可以读取另一个事务修改但没有提交的数据。该级别不能防止脏读和不可重复读，很少使用。
TransactionDefinition.ISOLATION_READ_COMMITTED 			一个事务只能读取另一个事务已经提交的数据，该级别可以防止脏读，使用最多的。
TransactionDefinition.ISOLATION_REPEATABLE_READ			一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同，即时在多次查询之间有新增的数据满足该查询，这些新记录也会被忽略，该级别可以防止脏读和不可重复读。
TransactionDefinition.ISOLATION_SERIALIZABLE 			所有的事务依次执行，这样每个事务之间就不会干扰，也就是说，该级别可以防止脏读，不可重复读和幻读，但是很影响程序性能，一般很少使用。

spring事务的传播机制
TransactionDefinition.PROPAGATION_REQUIRED  			如果当前存在事务，则加入该事务，如果当前没有事务，则创建一个新的事务。
TransactionDefinition.PROPAGATION_REQUIRES_NEW			创建一个新的事务，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_SUPPORTS				如果当前存在事务，则加入该事务，如果当前不存在事务，则以非事务的方式继续运行。
TransactionDefinition.PROPAGATION_NOT_SUPPORTED			以非事务的方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER					以非事务的方式运行，如果当前存在事务，则抛出异常。
TransactionDefinition.PROPAGATION_MANDATORY				如果当前存在事务，则加入该事务，如果当前没有事务，则抛出异常。
TransactionDefinition.PROPAGATION_NESTED				如果当前存在事务，则创建一个事务作为当前事务的嵌套事务执行，如果当前没有事务，则创建一个新的事务。


required	英[rɪˈkwaɪəd]  需要; 依靠; 依赖
transaction	英[trænˈzækʃn]
definition	英[ˌdefɪˈnɪʃn]
propagation	英[ˌprɒpə'ɡeɪʃ(ə)n] 传播
mandatory	英[ˈmændətəri]
nested		英[ˈnestɪd]

# Java对象的序列化和反序列化
#### 一、序列化的概念
把对象转换为字节序列的过程称为对象的序列化。
把字节序列恢复为对象的过程称为对象的反序列化。

对象的序列化主要有两种用途：
1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
2） 在网络上传送对象的字节序列。

#### 二、什么场景会涉及序列化和反序列化的概念

   在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些session先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。

当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。

举个真实的案例：当我们需要使用的对象很复杂或者需要很长时间去构造，这时就会引入使用代理模式(Proxy)。例如：如果构建一个对象很耗费时间和计算机资源，代理模式(Proxy)允许我们控制这种情况，直到我们需要使用实际的对象。一个代理(Proxy)通常包含和将要使用的对象同样的方法，一旦开始使用这个对象，这些方法将通过代理(Proxy)传递给实际的对象。 

解读：在微服务化盛行的今天，很多复杂的对象构造起来比较耗时，为了节省开支，某些公司将这部分复杂的对象先圈起来，写成服务起在远端B,并在调用端A端以代理（Proxy）的形式提供对服务的访问，这期间从B到A远程调的过程形成了Java对象序列化和反序列化的相关操作！

#### 三、serialVersionUID的作用
** serialVersionUID **:字面意思上是序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量

** 序列化版本ID的真实用途 **：当实体中增加属性后，文件流中的class和classpath中的class，也就是修改过后的class，不兼容了，处于安全机制考虑，程序抛出了错误，并且拒绝载入。那么如果我们真的有需求要在序列化后添加一个字段或者方法呢？应该怎么办？那就是自己去指定serialVersionUID。在例子中，如果没有指定Person类的serialVersionUID的，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，添加了一个字段后，由于没有显指定serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。可以说serialVersionUID是序列化和反序列化之间彼此认识的唯一信物。

**serialVersionUID的取值** 是Java运行时环境根据类的内部细节自动生成的。如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。

类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。

显式地定义serialVersionUID有两种用途：

1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；
2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。

synchronzied的底层实现原理及各种优化
synchronized是JAVA的内建锁，用来保证线程安全的，是解决并发问题的一种重要手段，synchronized可以保证在多线程状态下，每次仅有一个线程访问共享资源。
synchronized的主要作用有三个，
第一个是原子性，线程互斥的访问同步代码块，可以将小原子合成大原子。
第二个是可见性，synchronized解锁前必须将工作内存中的数据同步到主存中，其他线程在操作改变量时每次都可以看到被修改的值。
第三个是有序性，一个线程的加锁，必须等到其他线程将锁释放，一个线程要释放锁必须先加锁。
synchronized在使用过程中并没有显示的看到加锁和解锁的过程，可以通过javap命令，查看相应的字节码文件。

synchronized是一个可重入锁，可重入锁的原理
每一个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有没任何线程持有，那么任何线程都可以获得该锁而调用相应的方法，当某一线程获得该锁时，JVM会记下锁的持有线程，并将该锁的计数器置为1，
其他线程想要获得该锁必须等待，而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增，当线程退出同步代码块时，计数器会递减，当计数器为0时，则释放该锁。

优化手段
第一个是偏向锁
第二个是轻量锁
第三个是重量锁
当没有竞争出现时，默认会使用偏向锁，当有另外的线程试图获得已经被偏向锁锁定的对象时，jvm就会撤销偏向锁，并升级成轻量级锁，如果获得成功，就用轻量级锁，否则继续升级为重量级锁。

乐观锁vs悲观锁
悲观锁就是对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
乐观锁认为



快速排序
概念：在数组中选择一个基准值，通过排序将小于基准值得放在基准值的左边，将大于基准值的放在右边，再对数组递归调用排序，重复这个过程。
平均时间复杂度：O（n） 最坏时间复杂度：O（n^2） 空间复杂度：O（logn） 稳定

动态代理的作用
1.代理类的代码量被固定下来，不会因业务的逐渐庞大而庞大。
2.可以实现AOP编程。
3.解耦，通过参数就可以判断真实类，不需要先实例化，更加灵活。

动态代理的优点
通过在原有的调用逻辑中，再抽取一个代理类的方式，使调用的变化尽量封装在代理类中，达到不去改动原有被代理类方法的情况下，实现新的动作的结果。
缺点
静态代理和动态代理都需要被代理类的接口信息以确定特定的方法进行拦截和包装。
CGLib动态代理虽然不需要接口信息，但是他拦截被代理类的所有方法。

当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。
Dns解析–>端口分析–>tcp请求–>服务器处理请求–>服务器响应–>浏览器解析—>链接关闭

MYsql 的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。
索引是通过复杂的算法，提高数据查询性能的手段。从磁盘io到内存io的转变
普通索引，主键，唯一，单列/多列索引建索引的几大原则
1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

Mysql 怎么优化 table scan 的。
避免在where子句中对字段进行is null判断
应尽量避免在where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
避免在where 子句中使用or 来连接条件
in 和not in 也要慎用
Like查询（非左开头）
使用NUM=@num参数这种
where 子句中对字段进行表达式操作num/2=XX
在where子句中对字段进行函数操作

ACID 是什么。
A，atomic，原子性，要么都提交，要么都失败，不能一部分成功，一部分失败。
C，consistent，一致性，事物开始及结束后，数据的一致性约束没有被破坏
I，isolation，隔离性，并发事物间相互不影响，互不干扰。
D，durability,持久性，已经提交的事物对数据库所做的更新必须永久保存。即便发生崩溃，也不能被回滚或数据丢失。

简单介绍一个redis？

redis是内存中的数据结构存储系统，一个key-value类型的非关系型数据库，可持久化的数据库，相对于关系型数据库（数据主要存在硬盘中），性能高，因此我们一般用redis来做缓存使用；并且redis支持丰富的数据类型，比较容易解决各种问题，因此redis可以用来作为注册中心，​数据库、缓存和消息中间件。Redis的Value支持5种数据类型，string、hash、list、set、zset（sorted set）;
Redis：适用于对读写效率要求高、数据处理业务复杂、安全性要求较高的系统
案例：分布式系统，存在session之间的共享问题，因此在做单点登录的时候，我们利用redis来模拟了session的共享，来存储用户的信息，实现不同系统的session共享；

redis的持久化方式有两种：
RDB（半持久化方式）
按照配置不定期的通过异步的方式、快照的形式直接把内存中的数据持久化到磁盘的一个dump.rdb文件（二进制的临时文件）中，redis默认的持久化方式，它在配置文件（redis.conf）中。
优点：只包含一个文件，将一个单独的文件转移到其他存储媒介上，对于文件备份、灾难恢复而言，比较实用。
缺点：系统一旦在持久化策略之前出现宕机现象，此前没有来得及持久化的数据将会产生丢失

AOF（全持久化的方式）
把每一次数据变化都通过write()函数将你所执行的命令追加到一个appendonly.aof文件里面，Redis默认是不支持这种全持久化方式的，需要在配置文件（redis.conf）中将appendonly no改成appendonly yes
优点：数据安全性高，对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机问题，也不会破坏日志文件中已经存在的内容；
缺点：对于数量相同的数据集来说，aof文件通常要比rdb文件大，因此rdb在恢复大数据集时的速度大于AOF；

二种持久化方式区别：

AOF在运行效率上往往慢于RDB，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效；

如果缓存数据安全性要求比较高的话，用aof这种持久化方式（比如项目中的购物车）；

如果对于大数据集要求效率高的话，就可以使用默认的。而且这两种持久化方式可以同时使用。  

线程有几种实现方式？
继承Thread类
实现Runnable接口
实现Callable接口
线程池方式

spring Cloud 核心组件
1.Eureka
	Eureka server：服务注册中心，里边有一个注册表，保存了各个服务所在的机器和端口号。
	Eureka Client：负责将这个服务注册到Eureka server。
2.Feign Client ：会在底层根据注解和指定的服务建立连接、构造请求、发起请求、获取响应、解析响应。
	Feign的关键机制就是使用了动态代理。
	1）首先，如果你对某个接口定义了FeignClient注解，Feign就会针对这个接口创建一个动态代理。
	2）接着要是调用这个接口，本质就是会调用Feign创建的动态代理
	3）Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出要请求的服务地址
	4）最后根据这个地址发起请求解析响应。
3.Ribbon
	Ribbon的作用是负载均衡，会均匀的把请求分发到每个服务器上，Ribbon的负载均衡策略默认使用轮询算法。
	工作原理：
	1）首先Ribbon会从Eureka Client里获取到每个服务的注册表，也就知道了所有的服务部署在那些机器上，在监听哪些端口。
	2）然后Ribbon就可以使用默认的Round Ribbon算法，从中选择一台机器。
	3）Feign就会针对这台机器，构造并发起请求。
4.Hystrix
	Hystrix是一个可以做到隔离，熔断，降级的框架，Hystrix会根据服务创建很多线程池，每个线程池里的线程只用于请求那个服务。
	1）使用命令模式将所有对外部的服务的调用包装起来，并将该对象放在单独的线程中执行。
	2）每个依赖都维护一个线程池，当线程池被耗尽则拒绝请求，（而不是让请求排队）
	3）记录请求成功、失败、超时和线程拒绝。
	4）服务错误百分比超过阈值，熔断器开关自动打开，一段时间内停止对该服务的所有请求。
	5）请求失败，被拒绝，超时或熔断时执行降级逻辑。
	6）近实时的监控指标和配置的修改。
